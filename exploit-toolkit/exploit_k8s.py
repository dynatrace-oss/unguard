import sys

from typing import Optional

import click
from rich.console import Console
from rich.table import Table

from exploits.kubernetes.container.assessment.scanner import SecurityScanner
from exploits.kubernetes.container.core.config import Config
from exploits.kubernetes.container.core.k8s_client import K8sClient
from exploits.kubernetes.container.core.logger import SecurityLogger, setup_logger
from exploits.kubernetes.container.make_vulnerable import (
    DangerousCapabilitiesExploit,
    HostNamespaceSharingExploit,
    MissingResourceLimitsExploit,
    PrivilegedContainersExploit,
)
from exploits.kubernetes.container.remediations.patcher import SecurityPatcher

console = Console()

# Exploit registry
EXPLOITS = {
    "privileged-containers": PrivilegedContainersExploit,
    "dangerous-capabilities": DangerousCapabilitiesExploit,
    "host-namespace-sharing": HostNamespaceSharingExploit,
    "missing-resource-limits": MissingResourceLimitsExploit,
}


@click.group()
@click.option("--namespace", "-n", default="unguard", help="Target namespace")
@click.option("--debug", is_flag=True, help="Enable debug output")
@click.option("--dry-run", is_flag=True, help="Preview changes without applying")
@click.option("--verbose", "-v", is_flag=True, help="Enable verbose output")
@click.pass_context
def cli(ctx, namespace: str, debug: bool, dry_run: bool, verbose: bool):
   """Kubernetes Container Security Lab - Assessment and Exploitation Toolkit."""
   ctx.ensure_object(dict)
   
   # Setup configuration
   config = Config.from_env()
   config.namespace = namespace
   config.debug = debug
   config.dry_run = dry_run
   config.verbose = verbose  # Add verbose to config
   
   # Setup logger
   logger = SecurityLogger(setup_logger("k8s_security", debug=debug))
   
   # Initialize Kubernetes client
   try:
       k8s_client = K8sClient(namespace=namespace, logger=logger, verbose=verbose)
   except Exception as e:
       logger.error(f"Failed to initialize Kubernetes client: {e}")
       sys.exit(1)
   
   # Store in context
   ctx.obj["config"] = config
   ctx.obj["logger"] = logger
   ctx.obj["k8s"] = k8s_client
   
   # Banner for main commands
   if ctx.invoked_subcommand in ["assess", "exploit", "secure", "verify"]:
       console.print("\n[bold]Kubernetes Container Security Lab[/bold]")
       console.print(f"Namespace: {namespace}\n")


@cli.command()
@click.argument("service", required=False)
@click.pass_context
def assess(ctx, service: Optional[str]):
   """Assess security posture of services."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   scanner = SecurityScanner(k8s, logger)
   
   if service:
       scanner.assess_service(service)
   else:
       scanner.assess_all_services(config.services)


@cli.command()
@click.pass_context
def vuln(ctx):
   """Apply all standard vulnerabilities (DANGEROUS!)."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   logger.warning("Applying all security vulnerabilities for demonstration...")
   logger.warning("This will make services EXTREMELY VULNERABLE!")
   
   if not config.dry_run:
       response = click.confirm("Are you absolutely sure?", default=False)
       if not response:
           logger.info("Cancelled")
           return
   
   # Apply vulnerabilities
   for exploit_type, service in config.exploit_mappings.items():
       if exploit_type in EXPLOITS:
           logger.warning(f"Applying {exploit_type} vulnerability to {service}...")
           exploit_class = EXPLOITS[exploit_type]
           exploit = exploit_class(k8s, service, logger)
           exploit.make_vulnerable(dry_run=config.dry_run)
   
   if not config.dry_run:
       logger.warning("All vulnerabilities applied!")
       console.print("\n‚ö†Ô∏è  Services are now HIGHLY VULNERABLE:")
       console.print("  ‚Ä¢ Profile service: FULLY PRIVILEGED with ALL capabilities")
       console.print("  ‚Ä¢ Payment service: Privileged mode enabled")
       console.print("  ‚Ä¢ Frontend: Host namespace access")
       console.print("  ‚Ä¢ Membership service: No resource limits")

# In exploit_k8s.py, update the vuln_service command:
@cli.command()
@click.argument("service")
@click.argument("vuln_type", type=click.Choice(["privileged", "capabilities", "host-namespace", "no-limits", "all"]))
@click.pass_context
def vuln_service(ctx, service: str, vuln_type: str):
    logger = ctx.obj["logger"]
    k8s = ctx.obj["k8s"]
    
    logger.info(f"Applying {vuln_type} vulnerability to {service}...")
    
    # Map vulnerability types to exploit classes
    vuln_map = {
        "privileged": PrivilegedContainersExploit,
        "capabilities": DangerousCapabilitiesExploit,
        "host-namespace": HostNamespaceSharingExploit,
        "no-limits": MissingResourceLimitsExploit,
    }
    
    try:
        if vuln_type == "all":
            for exploit_class in vuln_map.values():
                exploit = exploit_class(k8s, service, logger)
                exploit.make_vulnerable(dry_run=ctx.obj["config"].dry_run)
        else:
            exploit_class = vuln_map.get(vuln_type)
            if not exploit_class:
                logger.error(f"Unknown vulnerability type: {vuln_type}")
                return
                
            exploit = exploit_class(k8s, service, logger)
            exploit.make_vulnerable(dry_run=ctx.obj["config"].dry_run)
            
        logger.success(f"Vulnerability {vuln_type} applied to {service}.")
    except Exception as e:
        logger.error(f"Failed to apply vulnerability: {e}")
        if ctx.obj["config"].debug:
            import traceback
            traceback.print_exc()

@cli.command()
@click.argument("exploit_type", required=False)
@click.option("--mode", type=click.Choice(["info", "vulnerable", "exploit", "demo"]), default="demo")
@click.pass_context
def exploit(ctx, exploit_type: Optional[str], mode: str):
    """Run security exploit demonstrations with modes."""
    config = ctx.obj["config"]
    logger = ctx.obj["logger"]
    k8s = ctx.obj["k8s"]

    if not exploit_type:
        console.print("[bold]Available Exploits:[/bold]")
        for name, cls in EXPLOITS.items():
            console.print(f"  ‚Ä¢ {name}: {cls.name} ({cls.risk_level})")
        return

    if exploit_type not in EXPLOITS:
        logger.error(f"Unknown exploit type: {exploit_type}")
        return

    # Get the correct service name from config
    service_name = config.exploit_mappings.get(exploit_type)
    if not service_name:
        logger.error(f"No service mapping found for exploit type: {exploit_type}")
        return

    exploit_class = EXPLOITS[exploit_type]
    exploit_instance = exploit_class(k8s, service_name, logger)

    try:
        if mode == "info":
            exploit_instance.show_info()
        elif mode == "vulnerable":
            exploit_instance.make_vulnerable()
        elif mode == "exploit":
            exploit_instance.run_exploit()
        elif mode == "demo":
            exploit_instance.run_interactive()
    except Exception as e:
        logger.error(f"Failed to run exploit: {e}")
        if config.debug:
            import traceback
            traceback.print_exc()


@cli.command()
@click.pass_context
def exploit_all(ctx):
   """Run all exploit demonstrations."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   logger.info("Running all container security exploits...")
   
   for exploit_type, service in config.exploit_mappings.items():
       if exploit_type in EXPLOITS:
           console.print(f"\n[bold]=== Exploit: {exploit_type} ===[/bold]")
           exploit_class = EXPLOITS[exploit_type]
           exploit_instance = exploit_class(k8s, service, logger)
           
           _ = exploit_instance.demonstrate()
           
           if not click.confirm("\nContinue to next exploit?", default=True):
               break
   
   logger.success("All exploits demonstrated")


@cli.command()
@click.argument("exploit_type", required=False)
@click.option("--service", "-s", help="Override target service")
@click.pass_context
def secure(ctx, exploit_type: Optional[str], service: Optional[str]):
   """Apply security remediations."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   patcher = SecurityPatcher(k8s, logger)
   
   if exploit_type:
       # Secure specific vulnerability
       if exploit_type not in EXPLOITS:
           logger.error(f"Unknown exploit type: {exploit_type}")
           return
       
       target_service = service or config.exploit_mappings.get(exploit_type)
       exploit_class = EXPLOITS[exploit_type]
       exploit_instance = exploit_class(k8s, target_service, logger)
       exploit_instance.make_secure(dry_run=config.dry_run)
   else:
       # Secure all services
       patcher.apply_all_remediations(config.exploit_mappings, EXPLOITS, config.dry_run)


@cli.command()
@click.pass_context
def verify(ctx):
   """Verify security improvements."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   logger.info("Verifying security improvements...")
   
   all_secure = True
   results = []
   
   for service in config.services:
       pod_name = k8s.find_pod_for_service(service)
       if not pod_name:
           results.append((service, "No pod found", False))
           all_secure = False
           continue
       
       try:
           pod = k8s.v1.read_namespaced_pod(pod_name, k8s.namespace)
           issues = []
           
           # Check privileged
           container = pod.spec.containers[0]
           if container.security_context and container.security_context.privileged:
               issues.append("Privileged")
           
           # Check capabilities
           if (container.security_context and 
               container.security_context.capabilities and
               container.security_context.capabilities.add):
               issues.append("Dangerous capabilities")
           
           # Check host access
           if pod.spec.host_pid or pod.spec.host_network or pod.spec.host_ipc:
               issues.append("Host namespace access")
           
           # Check resource limits
           if not container.resources or not container.resources.limits:
               issues.append("No resource limits")
           
           if issues:
               results.append((service, ", ".join(issues), False))
               all_secure = False
           else:
               results.append((service, "Secure", True))
               
       except Exception as e:
           results.append((service, f"Error: {e}", False))
           all_secure = False
   
   # Display results
   table = Table(title="Security Verification Results")
   table.add_column("Service", style="cyan")
   table.add_column("Status", style="white")
   table.add_column("Secure", style="white")
   
   for service, status, secure in results:
       table.add_row(
           service,
           status,
           "‚úÖ" if secure else "‚ùå"
       )
   
   console.print(table)
   
   if all_secure:
       logger.secure("All security verifications passed! üéâ")
       console.print("\nThe containers are now properly secured with:")
       console.print("  ‚Ä¢ Non-privileged execution")
       console.print("  ‚Ä¢ Dropped capabilities")
       console.print("  ‚Ä¢ Resource limits")
       console.print("  ‚Ä¢ Host isolation")
       console.print("  ‚Ä¢ Disabled privilege escalation")
   else:
       logger.warning("Some security issues remain. Please review the output above.")


@cli.command()
@click.argument("service", required=False)
@click.option("--revision", "-r", type=int, help="Rollback to specific revision")
@click.pass_context
def rollback(ctx, service: Optional[str], revision: Optional[int]):
   """Rollback deployment changes."""
   config = ctx.obj["config"]
   k8s = ctx.obj["k8s"]
   
   if service:
       # Rollback specific service
       k8s.rollback_deployment(service, revision)
   else:
       # Rollback all services
       for svc in config.services:
           k8s.rollback_deployment(svc, revision)


@cli.command()
@click.pass_context
def rollback_original(ctx):
   """Rollback all services to original version (revision 1)."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   logger.info("Rolling back all services to original versions...")
   
   for service in config.services:
       k8s.rollback_deployment(service, revision=1)


@cli.command()
@click.pass_context
def status(ctx):
   """Show current deployment and security status."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   logger.info("Checking current status...")
   
   # Check namespace
   console.print("\n[bold]Namespace Status[/bold]")
   try:
       ns = k8s.v1.read_namespace(config.namespace)
       console.print(f"‚úÖ Namespace '{ns}' exists")
   except Exception:
       console.print("‚ùå Namespace not found")
       return
   
   # Check deployments
   console.print("\n[bold]Deployment Status[/bold]")
   deployments = k8s.apps_v1.list_namespaced_deployment(config.namespace)
   
   for dep in deployments.items:
       ready = f"{dep.status.ready_replicas or 0}/{dep.spec.replicas}"
       if dep.status.ready_replicas == dep.spec.replicas:
           console.print(f"‚úÖ {dep.metadata.name}: {ready}")
       else:
           console.print(f"‚ö†Ô∏è  {dep.metadata.name}: {ready}")
   
   # Security status
   console.print("\n[bold]Security Status[/bold]")
   scanner = SecurityScanner(k8s, logger)
   scanner.quick_security_check(config.services)


@cli.command()
@click.argument("service")
@click.pass_context
def secure_service(ctx, service: str):
   """Secure specific service."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   # Normalize service name - check if it's already a full service name
   if not service.startswith("unguard-"):
       service = f"unguard-{service}"
   
   # Check if service exists
   if not k8s.deployment_exists(service, config.namespace):
       original_service = service.replace("unguard-", "")
       if k8s.deployment_exists(original_service, config.namespace):
           service = original_service
       else:
           logger.error(f"Service {service} not found in namespace {config.namespace}")
           return
   
   patcher = SecurityPatcher(k8s, logger)
   patcher.secure_service(service, config.dry_run)


def main():
   """Main entry point."""
   cli(obj={})


if __name__ == "__main__":
   main()