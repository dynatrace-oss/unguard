import sys

from typing import Optional

import click
from rich.console import Console
from rich.table import Table

from exploits.kubernetes.container.assessment.scanner import SecurityScanner
from exploits.kubernetes.container.core.config import Config
from exploits.kubernetes.container.core.k8s_client import K8sClient
from exploits.kubernetes.container.core.logger import SecurityLogger, setup_logger
from exploits.kubernetes.container.make_vulnerable import (
    DangerousCapabilitiesExploit,
    HostNamespaceSharingExploit,
    MissingResourceLimitsExploit,
    PrivilegedContainersExploit,
)
from exploits.kubernetes.container.remediations.patcher import SecurityPatcher
from exploits.kubernetes.container.utils.deployment import DeploymentManager

console = Console()

# Exploit registry
EXPLOITS = {
    "privileged-containers": PrivilegedContainersExploit,
    "dangerous-capabilities": DangerousCapabilitiesExploit,
    "host-namespace-sharing": HostNamespaceSharingExploit,
    "missing-resource-limits": MissingResourceLimitsExploit,
}


@click.group()
@click.option("--namespace", "-n", default="unguard", help="Target namespace")
@click.option("--debug", is_flag=True, help="Enable debug output")
@click.option("--dry-run", is_flag=True, help="Preview changes without applying")
@click.pass_context
def cli(ctx, namespace: str, debug: bool, dry_run: bool):
   """Kubernetes Container Security Lab - Assessment and Exploitation Toolkit."""
   ctx.ensure_object(dict)
   
   # Setup configuration
   config = Config.from_env()
   config.namespace = namespace
   config.debug = debug
   config.dry_run = dry_run
   
   # Setup logger
   logger = SecurityLogger(setup_logger("k8s_security", debug=debug))
   
   # Initialize Kubernetes client
   try:
       k8s_client = K8sClient(namespace=namespace, logger=logger)
   except Exception as e:
       logger.error(f"Failed to initialize Kubernetes client: {e}")
       sys.exit(1)
   
   # Store in context
   ctx.obj["config"] = config
   ctx.obj["logger"] = logger
   ctx.obj["k8s"] = k8s_client
   
   # Show banner for main commands
   if ctx.invoked_subcommand in ["assess", "exploit", "secure", "verify"]:
       console.print("\n[bold]Kubernetes Container Security Lab[/bold]")
       console.print(f"Namespace: {namespace}\n")


@cli.command()
@click.argument("service", required=False)
@click.pass_context
def assess(ctx, service: Optional[str]):
   """Assess security posture of services."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   scanner = SecurityScanner(k8s, logger)
   
   if service:
       scanner.assess_service(service)
   else:
       scanner.assess_all_services(config.services)


@cli.command()
@click.pass_context
def vuln(ctx):
   """Apply all standard vulnerabilities (DANGEROUS!)."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   logger.warning("Applying all security vulnerabilities for demonstration...")
   logger.warning("This will make services EXTREMELY VULNERABLE!")
   
   if not config.dry_run:
       response = click.confirm("Are you absolutely sure?", default=False)
       if not response:
           logger.info("Cancelled")
           return
   
   # Apply vulnerabilities
   for exploit_type, service in config.exploit_mappings.items():
       if exploit_type in EXPLOITS:
           logger.warning(f"Applying {exploit_type} vulnerability to {service}...")
           exploit_class = EXPLOITS[exploit_type]
           exploit = exploit_class(k8s, service, logger)
           exploit.make_vulnerable(dry_run=config.dry_run)
   
   if not config.dry_run:
       logger.warning("All vulnerabilities applied!")
       console.print("\n‚ö†Ô∏è  Services are now HIGHLY VULNERABLE:")
       console.print("  ‚Ä¢ Profile service: FULLY PRIVILEGED with ALL capabilities")
       console.print("  ‚Ä¢ Payment service: Privileged mode enabled")
       console.print("  ‚Ä¢ Frontend: Host namespace access")
       console.print("  ‚Ä¢ Membership service: No resource limits")

@cli.command()
@click.argument("service")
@click.argument("vuln_type", type=click.Choice(["privileged", "capabilities", "host-namespace", "no-limits", "all"]))
@click.pass_context
def vuln_service(ctx, service: str, vuln_type: str):
    """Apply specific vulnerability to any service."""
    logger = ctx.obj["logger"]
    k8s = ctx.obj["k8s"]

    logger.info(f"Applying {vuln_type} vulnerability to {service}...")
    try:
        patcher = SecurityPatcher(k8s, logger)
        patcher.apply_vulnerability_to_service(service, vuln_type, ctx.obj["config"].dry_run)
        logger.success(f"Vulnerability {vuln_type} applied to {service}.")
    except Exception as e:
        logger.error(f"Failed to apply vulnerability: {e}")

@cli.command()
@click.argument("exploit_type", required=False)
@click.option("--mode", type=click.Choice(["info", "vulnerable", "exploit", "demo"]), default="demo")
@click.pass_context
def exploit(ctx, exploit_type: Optional[str], mode: str):
    """Run security exploit demonstrations with modes."""
    logger = ctx.obj["logger"]
    k8s = ctx.obj["k8s"]

    if not exploit_type:
        console.print("[bold]Available Exploits:[/bold]")
        for name, cls in EXPLOITS.items():
            console.print(f"  ‚Ä¢ {name}: {cls.name} ({cls.risk_level})")
        return

    if exploit_type not in EXPLOITS:
        logger.error(f"Unknown exploit type: {exploit_type}")
        return

    exploit_class = EXPLOITS[exploit_type]
    exploit_instance = exploit_class(k8s, ctx.obj["config"].namespace, logger)

    try:
        if mode == "info":
            exploit_instance.show_info()
        elif mode == "vulnerable":
            exploit_instance.make_vulnerable()
        elif mode == "exploit":
            exploit_instance.run_exploit()
        elif mode == "demo":
            exploit_instance.run_interactive()
    except Exception as e:
        logger.error(f"Failed to run exploit: {e}")


@cli.command()
@click.pass_context
def exploit_all(ctx):
   """Run all exploit demonstrations."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   logger.info("Running all container security exploits...")
   
   for exploit_type, service in config.exploit_mappings.items():
       if exploit_type in EXPLOITS:
           console.print(f"\n[bold]=== Exploit: {exploit_type} ===[/bold]")
           exploit_class = EXPLOITS[exploit_type]
           exploit_instance = exploit_class(k8s, service, logger)
           
           _ = exploit_instance.demonstrate()
           
           if not click.confirm("\nContinue to next exploit?", default=True):
               break
   
   logger.success("All exploits demonstrated")


@cli.command()
@click.argument("exploit_type", required=False)
@click.option("--service", "-s", help="Override target service")
@click.pass_context
def secure(ctx, exploit_type: Optional[str], service: Optional[str]):
   """Apply security remediations."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   patcher = SecurityPatcher(k8s, logger)
   
   if exploit_type:
       # Secure specific vulnerability
       if exploit_type not in EXPLOITS:
           logger.error(f"Unknown exploit type: {exploit_type}")
           return
       
       target_service = service or config.exploit_mappings.get(exploit_type)
       exploit_class = EXPLOITS[exploit_type]
       exploit_instance = exploit_class(k8s, target_service, logger)
       exploit_instance.make_secure(dry_run=config.dry_run)
   else:
       # Secure all services
       patcher.apply_all_remediations(config.exploit_mappings, EXPLOITS, config.dry_run)


@cli.command()
@click.pass_context
def verify(ctx):
   """Verify security improvements."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   logger.info("Verifying security improvements...")
   
   all_secure = True
   results = []
   
   for service in config.services:
       pod_name = k8s.find_pod_for_service(service)
       if not pod_name:
           results.append((service, "No pod found", False))
           all_secure = False
           continue
       
       try:
           pod = k8s.v1.read_namespaced_pod(pod_name, k8s.namespace)
           issues = []
           
           # Check privileged
           container = pod.spec.containers[0]
           if container.security_context and container.security_context.privileged:
               issues.append("Privileged")
           
           # Check capabilities
           if (container.security_context and 
               container.security_context.capabilities and
               container.security_context.capabilities.add):
               issues.append("Dangerous capabilities")
           
           # Check host access
           if pod.spec.host_pid or pod.spec.host_network or pod.spec.host_ipc:
               issues.append("Host namespace access")
           
           # Check resource limits
           if not container.resources or not container.resources.limits:
               issues.append("No resource limits")
           
           if issues:
               results.append((service, ", ".join(issues), False))
               all_secure = False
           else:
               results.append((service, "Secure", True))
               
       except Exception as e:
           results.append((service, f"Error: {e}", False))
           all_secure = False
   
   # Display results
   table = Table(title="Security Verification Results")
   table.add_column("Service", style="cyan")
   table.add_column("Status", style="white")
   table.add_column("Secure", style="white")
   
   for service, status, secure in results:
       table.add_row(
           service,
           status,
           "‚úÖ" if secure else "‚ùå"
       )
   
   console.print(table)
   
   if all_secure:
       logger.secure("All security verifications passed! üéâ")
       console.print("\nThe containers are now properly secured with:")
       console.print("  ‚Ä¢ Non-privileged execution")
       console.print("  ‚Ä¢ Dropped capabilities")
       console.print("  ‚Ä¢ Resource limits")
       console.print("  ‚Ä¢ Host isolation")
       console.print("  ‚Ä¢ Disabled privilege escalation")
   else:
       logger.warning("Some security issues remain. Please review the output above.")


@cli.command()
@click.argument("service", required=False)
@click.option("--revision", "-r", type=int, help="Rollback to specific revision")
@click.pass_context
def rollback(ctx, service: Optional[str], revision: Optional[int]):
   """Rollback deployment changes."""
   config = ctx.obj["config"]
   k8s = ctx.obj["k8s"]
   
   if service:
       # Rollback specific service
       k8s.rollback_deployment(service, revision)
   else:
       # Rollback all services
       for svc in config.services:
           k8s.rollback_deployment(svc, revision)


@cli.command()
@click.pass_context
def rollback_original(ctx):
   """Rollback all services to original version (revision 1)."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   logger.info("Rolling back all services to original versions...")
   
   for service in config.services:
       k8s.rollback_deployment(service, revision=1)


@cli.command()
@click.pass_context
def status(ctx):
   """Show current deployment and security status."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   logger.info("Checking current status...")
   
   # Check namespace
   console.print("\n[bold]Namespace Status[/bold]")
   try:
       ns = k8s.v1.read_namespace(config.namespace)
       console.print(f"‚úÖ Namespace '{ns}' exists")
   except Exception:
       console.print("‚ùå Namespace not found")
       return
   
   # Check deployments
   console.print("\n[bold]Deployment Status[/bold]")
   deployments = k8s.apps_v1.list_namespaced_deployment(config.namespace)
   
   for dep in deployments.items:
       ready = f"{dep.status.ready_replicas or 0}/{dep.spec.replicas}"
       if dep.status.ready_replicas == dep.spec.replicas:
           console.print(f"‚úÖ {dep.metadata.name}: {ready}")
       else:
           console.print(f"‚ö†Ô∏è  {dep.metadata.name}: {ready}")
   
   # Security status
   console.print("\n[bold]Security Status[/bold]")
   scanner = SecurityScanner(k8s, logger)
   scanner.quick_security_check(config.services)


@cli.command()
@click.pass_context  
def interactive(ctx):
   """Interactive learning mode."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   console.print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   Kubernetes Container Security ----  Interactive Mode        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Welcome to the interactive container security tutorial!

This lab will guide you through:
1. Assessing current security posture
2. Introducing controlled vulnerabilities
3. Demonstrating real exploits
4. Applying security remediations
5. Verifying improvements
""")
   
   if not click.confirm("Ready to start?", default=True):
       return
   
   # Step 1: Assessment
   console.print("\n[bold]Step 1: Security Assessment[/bold]")
   console.print("First, let's check the current security posture...")
   click.pause("Press any key to run security assessment...")
   
   scanner = SecurityScanner(k8s, logger)
   scanner.assess_all_services(config.services)
   
   click.pause("\nNotice the security gaps? Press any key to continue...")
   
   # Step 2: Exploits
   console.print("\n[bold]Step 2: Demonstrating Exploits[/bold]")
   console.print("Now let's see how attackers could exploit these misconfigurations...")
   click.pause("Press any key to start exploit demonstrations...")
   
   for exploit_type, service in config.exploit_mappings.items():
       if exploit_type in EXPLOITS:
           console.print(f"\n[bold]=== {exploit_type} ===[/bold]")
           exploit_class = EXPLOITS[exploit_type]
           exploit_instance = exploit_class(k8s, service, logger)
           exploit_instance.run_interactive()
           
           if not click.confirm("\nContinue?", default=True):
               break
   
   # Step 3: Remediation
   console.print("\n[bold]Step 3: Applying Security Fixes[/bold]")
   console.print("Let's fix these vulnerabilities...")
   click.pause("Press any key to apply security remediations...")
   
   patcher = SecurityPatcher(k8s, logger)
   patcher.apply_all_remediations(config.exploit_mappings, EXPLOITS, config.dry_run)
   
   # Step 4: Verification
   console.print("\n[bold]Step 4: Verifying Security[/bold]")
   console.print("Finally, let's verify our fixes work...")
   click.pause("Press any key to verify security improvements...")
   
   ctx.invoke(verify)
   
   console.print("\n[bold green]Tutorial completed! üéâ[/bold green]")
   console.print("\nKey takeaways:")
   console.print("- Container security requires explicit configuration")
   console.print("- Default settings are often insecure")
   console.print("- Multiple layers of defense are necessary")
   console.print("- Continuous monitoring is essential")


@cli.command()
@click.pass_context
def cleanup(ctx):
   """Interactive cleanup menu."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   while True:
       console.print("\n[bold]Cleanup Options[/bold]")
       console.print("1) Show current status")
       console.print("2) Rollback all patches (keep Unguard)")
       console.print("3) Rollback specific service")
       console.print("4) Uninstall Unguard Helm release")
       console.print("5) Delete entire namespace")
       console.print("6) Exit cleanup")
       
       choice = click.prompt("Choose option", type=int)
       
       if choice == 1:
           ctx.invoke(status)
       elif choice == 2:
           ctx.invoke(rollback)
       elif choice == 3:
           service = click.prompt("Enter service name")
           ctx.invoke(rollback, service=service)
       elif choice == 4:
           manager = DeploymentManager(k8s, logger)
           manager.uninstall_unguard()
       elif choice == 5:
           if click.confirm(f"Delete namespace '{config.namespace}'?", default=False):
               k8s.v1.delete_namespace(config.namespace)
               logger.success("Namespace deletion initiated")
               break
       elif choice == 6:
           break


@cli.command()
@click.argument("service")
@click.pass_context
def secure_service(ctx, service: str):
   """Secure specific service."""
   config = ctx.obj["config"]
   logger = ctx.obj["logger"]
   k8s = ctx.obj["k8s"]
   
   # Normalize service name
   if not service.startswith("unguard-"):
       service = f"unguard-{service}"
   
   # Check if service exists
   if not k8s.get_deployment(service):
       logger.error(f"Service {service} not found in namespace {config.namespace}")
       return
   
   patcher = SecurityPatcher(k8s, logger)
   patcher.secure_service(service, config.dry_run)


def main():
   """Main entry point."""
   cli(obj={})


if __name__ == "__main__":
   main()