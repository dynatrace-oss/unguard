from typing import Dict, List, Type
from ..core.k8s_client import K8sClient
from ..core.logger import SecurityLogger
from ..make_vulnerable.base import BaseExploit
import os
import subprocess


class SecurityPatcher:
    """Handles security patching operations."""
    def __init__(self, k8s_client: K8sClient, logger: SecurityLogger):
        self.k8s = k8s_client
        self.logger = logger

    def apply_all_remediations(
        self,
        exploit_mappings: Dict[str, str],
        exploit_classes: Dict[str, Type[BaseExploit]],
        dry_run: bool = False
    ) -> None:
        """Apply all security remediations."""
        self.logger.secure("Applying comprehensive security remediations...")
        for exploit_type, service in exploit_mappings.items():
            if exploit_type in exploit_classes:
                self.logger.secure(f"Applying security fix for {exploit_type} on {service}...")
                exploit_class = exploit_classes[exploit_type]
                exploit = exploit_class(self.k8s, service, self.logger)
                exploit.make_secure(dry_run=dry_run)
        if not dry_run:
            self.logger.secure("All security remediations applied!")

    def apply_vulnerability_to_service(
        self,
        service: str,
        vuln_type: str,
        dry_run: bool = False,
        timeout: int = 120
    ) -> bool:
        """Apply specific vulnerability to any service."""
        self.logger.info(f"Applying {vuln_type} vulnerability to {service}...")
        patches = self._get_vulnerability_patches(vuln_type)
        if not patches or not self._validate_patch(patches):
            self.logger.error(f"Invalid or unknown vulnerability type: {vuln_type}")
            return False
        self._ensure_security_context(service)
        if self.k8s.patch_deployment(service, patches, dry_run):
            if not dry_run:
                self.logger.success(f"Successfully made {service} vulnerable with {vuln_type}")
                self.k8s.wait_for_rollout(service, timeout)
            return True
        return False

    def secure_service(self, service: str, dry_run: bool = False, timeout: int = 120) -> bool:
        """Remove all vulnerabilities from a service."""
        self.logger.info(f"Securing {service}...")
        patches = self._get_secure_patches()
        self._ensure_security_context(service)
        if self.k8s.patch_deployment(service, patches, dry_run):
            if not dry_run:
                self.logger.success(f"Successfully secured {service}")
                self.k8s.wait_for_rollout(service, timeout)
            return True
        return False

    def prepare_offline(self, output_dir: str = "offline-resources") -> None:
        """Prepare resources for offline environments."""
        self.logger.info("Preparing resources for offline use...")
        os.makedirs(output_dir, exist_ok=True)
        # Save manifests
        manifests = {
            "unguard": "https://raw.githubusercontent.com/dynatrace-oss/unguard/main/chart/unguard/values.yaml"
        }
        for name, url in manifests.items():
            self.logger.info(f"Downloading manifest for {name}...")
            manifest_path = os.path.join(output_dir, f"{name}.yaml")
            try:
                subprocess.run(["curl", "-o", manifest_path, url], check=True)
                self.logger.success(f"Saved {name} manifest to {manifest_path}")
            except subprocess.CalledProcessError:
                self.logger.error(f"Failed to download manifest for {name}")
        # Pull container images
        images = ["ghcr.io/dynatrace-oss/unguard:v1.0.0"]
        for image in images:
            self.logger.info(f"Pulling container image: {image}...")
            try:
                subprocess.run(["docker", "pull", image], check=True)
                self.logger.success(f"Pulled image: {image}")
                subprocess.run(["docker", "save", "-o", os.path.join(output_dir, f"{image.replace('/', '_')}.tar"), image], check=True)
                self.logger.success(f"Saved image {image} to {output_dir}")
            except subprocess.CalledProcessError:
                self.logger.error(f"Failed to pull or save image: {image}")

    def rollback_service(self, service: str, namespace: str, timeout: int = 120) -> bool:
        """Rollback a service to the previous revision."""
        self.logger.info(f"Rolling back {service}...")
        if not self.k8s.deployment_exists(service, namespace):
            self.logger.error(f"Deployment {service} not found")
            return False
        if self.k8s.rollback_deployment(service, namespace): # type: ignore[attr-defined]
            self.k8s.wait_for_rollout(service, timeout)
            self.logger.success(f"Rolled back {service}")
            return True
        self.logger.error(f"Failed to rollback {service}")
        return False

    def cleanup_services(self, services: List[str], namespace: str, action: str = "rollback") -> None:
        """Perform cleanup actions on services."""
        self.logger.info(f"Starting cleanup with action: {action}")
        for service in services:
            if action == "rollback":
                self.rollback_service(service, namespace)
            elif action == "delete":
                self.k8s.delete_deployment(service, namespace)
            else:
                self.logger.error(f"Unknown cleanup action: {action}")
        self.logger.info("Cleanup completed.")

    def _ensure_security_context(self, service: str) -> None:
        """Ensure security context exists for all containers in a deployment."""
        deployment = self.k8s.get_deployment(service)
        if not deployment:
            return
        for idx, container in enumerate(deployment.spec.template.spec.containers): # type: ignore[attr-defined]
            if not hasattr(container, "security_context") or not container.security_context:
                self.k8s.patch_deployment(service, [
                    {"op": "add", "path": f"/spec/template/spec/containers/{idx}/securityContext", "value": {}}
                ])
            if "allowPrivilegeEscalation" not in container.security_context:
                self.k8s.patch_deployment(service, [
                    {"op": "add", "path": f"/spec/template/spec/containers/{idx}/securityContext/allowPrivilegeEscalation", "value": False}
                ])

    def _validate_namespace(self, namespace: str) -> bool:
        """Validate if the namespace exists."""
        if not self.k8s.namespace_exists(namespace):
            self.logger.error(f"Namespace {namespace} does not exist")
            return False
        return True

    def _validate_patch(self, patch: List[Dict]) -> bool:
        """Validate the patch structure."""
        try:
            # Ensure patch is a valid list of JSON objects
            for operation in patch:
                if not all(key in operation for key in ["op", "path"]):
                    raise ValueError(f"Invalid patch operation: {operation}")
            return True
        except Exception as e:
            self.logger.error(f"Invalid patch: {e}")
            return False

    def _get_vulnerability_patches(self, vuln_type: str) -> List[Dict]:
        """Get patches for specific vulnerability type."""
        patches = {
            "privileged": [
                {"op": "add", "path": "/spec/template/spec/containers/0/securityContext", "value": {}},
                {"op": "replace", "path": "/spec/template/spec/containers/0/securityContext/privileged", "value": True},
                {"op": "replace", "path": "/spec/template/spec/containers/0/securityContext/allowPrivilegeEscalation", "value": True},
                {"op": "add", "path": "/spec/template/spec/hostPID", "value": True},
            ],
            "capabilities": [
                {"op": "add", "path": "/spec/template/spec/containers/0/securityContext", "value": {}},
                {"op": "add", "path": "/spec/template/spec/containers/0/securityContext/capabilities", "value": {
                    "add": ["SYS_ADMIN", "NET_ADMIN", "SYS_PTRACE", "DAC_OVERRIDE", "SYS_MODULE", "SETUID", "SETGID"]
                }},
                {"op": "replace", "path": "/spec/template/spec/containers/0/securityContext/allowPrivilegeEscalation", "value": True},
            ],
            "host-namespace": [
                {"op": "add", "path": "/spec/template/spec/hostPID", "value": True},
                {"op": "add", "path": "/spec/template/spec/hostNetwork", "value": True},
                {"op": "add", "path": "/spec/template/spec/hostIPC", "value": True},
            ],
            "no-limits": [
                {"op": "remove", "path": "/spec/template/spec/containers/0/resources"},
            ],
            "all": [
                {"op": "add", "path": "/spec/template/spec/containers/0/securityContext", "value": {}},
                {"op": "replace", "path": "/spec/template/spec/containers/0/securityContext/privileged", "value": True},
                {"op": "replace", "path": "/spec/template/spec/containers/0/securityContext/allowPrivilegeEscalation", "value": True},
                {"op": "add", "path": "/spec/template/spec/containers/0/securityContext/capabilities", "value": {
                    "add": ["ALL"]
                }},
                {"op": "add", "path": "/spec/template/spec/hostPID", "value": True},
                {"op": "add", "path": "/spec/template/spec/hostNetwork", "value": True},
                {"op": "remove", "path": "/spec/template/spec/containers/0/resources"},
            ],
        }
        if vuln_type not in patches:
            self.logger.error(f"Unknown vulnerability type: {vuln_type}")
            return []
        return patches[vuln_type]

    def _get_secure_patches(self) -> List[Dict]:
        """Get patches to secure a service."""
        return [
            {"op": "add", "path": "/spec/template/spec/containers/0/securityContext", "value": {}},
            {"op": "replace", "path": "/spec/template/spec/containers/0/securityContext/runAsNonRoot", "value": True},
            {"op": "replace", "path": "/spec/template/spec/containers/0/securityContext/runAsUser", "value": 1000},
            {"op": "replace", "path": "/spec/template/spec/containers/0/securityContext/allowPrivilegeEscalation", "value": False},
            {"op": "replace", "path": "/spec/template/spec/containers/0/securityContext/privileged", "value": False},
            {"op": "replace", "path": "/spec/template/spec/containers/0/securityContext/capabilities", "value": {
                "drop": ["ALL"]
            }},
            {"op": "replace", "path": "/spec/template/spec/hostPID", "value": False},
            {"op": "replace", "path": "/spec/template/spec/hostNetwork", "value": False},
            {"op": "replace", "path": "/spec/template/spec/hostIPC", "value": False},
            {"op": "add", "path": "/spec/template/spec/containers/0/resources", "value": {
                "limits": {
                    "memory": "256Mi",
                    "cpu": "200m"
                },
                "requests": {
                    "memory": "128Mi",
                    "cpu": "100m"
                }
            }},
        ]
